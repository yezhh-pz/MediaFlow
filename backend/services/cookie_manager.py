"""
Cookie Manager Service - Handles storage and conversion of cookies for yt-dlp.
"""
from pathlib import Path
from typing import List, Dict, Any
from loguru import logger
import time


class CookieManager:
    """Manages cookies for different platforms, saving them in Netscape format."""
    
    def __init__(self, cookie_dir: Path = None):
        self.cookie_dir = cookie_dir or Path("temp/cookies")
        self.cookie_dir.mkdir(parents=True, exist_ok=True)
    
    def get_cookie_path(self, domain: str) -> Path:
        """Get the cookie file path for a domain."""
        # Normalize domain (remove www. prefix)
        clean_domain = domain.replace("www.", "")
        return self.cookie_dir / f"{clean_domain}.txt"
    
    def has_valid_cookies(self, domain: str) -> bool:
        """Check if we have a valid cookie file for the domain."""
        cookie_path = self.get_cookie_path(domain)
        if not cookie_path.exists():
            return False
        
        # Check if file is not empty and not too old (24 hours)
        if cookie_path.stat().st_size == 0:
            return False
        
        age_hours = (time.time() - cookie_path.stat().st_mtime) / 3600
        if age_hours > 24:
            logger.info(f"Cookie file for {domain} is too old ({age_hours:.1f}h)")
            return False
        
        return True
    
    def save_cookies(self, domain: str, cookies: List[Dict[str, Any]]) -> Path:
        """
        Save cookies in Netscape cookie file format.
        
        Format: domain  flag  path  secure  expiration  name  value
        """
        cookie_path = self.get_cookie_path(domain)
        
        lines = ["# Netscape HTTP Cookie File", "# This file was generated by Mediaflow"]
        
        for cookie in cookies:
            # Extract cookie fields
            cookie_domain = cookie.get("domain", domain)
            # Ensure domain starts with . for all subdomains
            if not cookie_domain.startswith("."):
                cookie_domain = "." + cookie_domain
            
            flag = "TRUE"  # Include subdomains
            path = cookie.get("path", "/")
            secure = "TRUE" if cookie.get("secure", False) else "FALSE"
            
            # Handle expiration
            expiration = cookie.get("expirationDate")
            if expiration:
                expiration = str(int(expiration))
            else:
                # Default to 1 year from now
                expiration = str(int(time.time()) + 31536000)
            
            name = cookie.get("name", "")
            value = cookie.get("value", "")
            
            if name and value:
                line = f"{cookie_domain}\t{flag}\t{path}\t{secure}\t{expiration}\t{name}\t{value}"
                lines.append(line)
        
        cookie_path.write_text("\n".join(lines), encoding="utf-8")
        logger.success(f"Saved {len(cookies)} cookies to {cookie_path.name}")
        
        return cookie_path
    
    def clear_cookies(self, domain: str) -> bool:
        """Delete cookies for a domain."""
        cookie_path = self.get_cookie_path(domain)
        if cookie_path.exists():
            cookie_path.unlink()
            logger.info(f"Cleared cookies for {domain}")
            return True
        return False


# Singleton instance

